local yagames = require("yagames.yagames")
local utf8 = require("example.ysdkdebug.utf8")

--
--
--

local log_node = nil
local log_text = ""
local log_prev = ""

local old_print = print
local print = function(...)
    local arg = {...}
    local t = ""
    for _, v in pairs(arg) do
        t = t .. tostring(v) .. " "
    end

    if not log_node then
        old_print(t)
        return
    end

    if log_prev == t then
        return
    end
    log_prev = t

    log_text = t .. "\n" .. log_text

    local pos = 1
    local lines = 0
    repeat
        pos = string.find(log_text, "\n", pos, true)
        if pos == nil then
            break
        end

        lines = lines + 1
        if lines == 52 then
            log_text = string.sub(log_text, 1, pos)
        end

        pos = pos + 1
    until false

    --old_print("log_text: " .. log_text)

    gui.set_text(log_node, log_text)
end

--
-- TV remote buttons test
--

local remote_keys = {
    hash("key_enter"),
    hash("key_tv_back"),
    hash("key_left"),
    hash("key_right"),
    hash("key_up"),
    hash("key_down")
}

local function message_show(self, text)
    local node = self.text_message
    gui.set_text(node, text)
    gui.cancel_animation(node, "color")
    gui.cancel_animation(node, "color.w")
    gui.set_color(node, vmath.vector4(0, 0, 0.7, 1))
    gui.animate(node, "color", vmath.vector4(0, 0, 0, 1), gui.EASING_OUTQUAD, 1, 0.2, function (self)
        gui.animate(node, "color.w", 0, gui.EASING_OUTQUAD, 0.3, 0.7)
    end)
end

local function remote_button_on(self, button_id)
    local node = gui.get_node(button_id)
    gui.cancel_animation(node, "color.w")
    gui.set_alpha(node, 0.5)
end

local function remote_button_off(self, button_id)
    local node = gui.get_node(button_id)
    gui.animate(node, "color.w", 0, gui.EASING_OUTQUAD, 0.3)
end

local function remote_input(self, action_id, action)
    if action_id and (action.pressed or action.released) then
        local action_value = action.pressed and "pressed" or (action.released and "released" or "")
        print("defold.on_input: " .. action_id  .. " - " .. action_value)
    end

    if action_id == hash("gamepad_raw") then
        local t = ""
        if action.gamepad_axis then
            for i = 1, #action.gamepad_axis do
                if math.abs(action.gamepad_axis[i]) > 0.5 then
                    t = t .. "axis["..i.."]("..action.gamepad_axis[i]..") "
                end
            end
        end
        if action.gamepad_buttons then
            for i = 1, #action.gamepad_buttons do
                if action.gamepad_buttons[i] > 0.5 then
                    t = t .. "buttons["..i.."]("..action.gamepad_buttons[i]..") "
                end
            end
        end
        if action.gamepad_hats then
            for i = 1, #action.gamepad_hats do
                if action.gamepad_hats[i] > 0.5 then
                    t = t .. "hats["..i.."]("..action.gamepad_hats[i]..") "
                end
            end
        end
        if #t > 0 then
            print("defold.on_input: " .. action_id .. " -> " .. t)
        end
    end

    for _, key_id in pairs(remote_keys) do
        if action_id == key_id then
            if action.pressed then
                remote_button_on(self, key_id)
            elseif action.released then
                remote_button_off(self, key_id)
            end
        end
    end

    if action_id == hash("key_tv_back") and action.released then
        self.back_hits = self.back_hits + 1
        message_show(self, "Hit BACK again to exit")

        if self.back_hits >= 2 then
            yagames.event_dispatch("EXIT")
        end
    end
end

local function remote_init(self)
    gui.set_text(self.text_device, "Device type is '" .. yagames.device_info_type() .. "'")

    for _, key_id in pairs(remote_keys) do
        local node = gui.get_node(key_id)
        gui.set_alpha(node, 0)
    end

    self.back_hits = 0
    message_show(self, "Press keys on your remote to test")

    yagames.event_on("HISTORY_BACK", function (self, err)
        print("yagames.event_on(\"HISTORY_BACK\"): " .. (err and "error " .. err or "OK"))

        if err then
            message_show(self, "'event_on' error " .. err)
            return
        end

        -- User pressed "BACK" on TV remote, i.e. 
        -- do something here.

        -- The following code simulates on_input, i.e. presses the button and immediately releases it.
        remote_input(self, hash("key_tv_back"), { pressed = true })
        remote_input(self, hash("key_tv_back"), { released = true })
    end)

    -- Test behaviour without a real Yandex TV
    -- timer.delay(3, true, function (self)
    --     remote_input(self, hash("key_tv_back"), { pressed = true })
    --     remote_input(self, hash("key_tv_back"), { released = true })
    -- end)
end

--
-- Script
--

local function js_listener(self, message_id, message)
    if message_id == "KeyDown" then
        print("window.onkeydown: " .. message)
    elseif message_id == "KeyUp" then
        print("window.onkeyup: " .. message)
    elseif message_id == "KeyPress" then
        print("window.onkeypress: " .. message)
    end
end

function init(self)
    self.text_message = gui.get_node("text_message")
    self.text_device = gui.get_node("text_device")
    self.text_version = gui.get_node("text_version")
    log_node = gui.get_node("text_log")

    gui.set_text(self.text_version, "Version " .. sys.get_config("project.version", "0.0.0"))

    if jstodef then
        jstodef.add_listener(js_listener)
    end
end

function final(self)
end

function update(self, dt)
end

function on_message(self, message_id, message, sender)
    if message_id == hash("init_done") then
        if message.err then
            message_show(self, "SDK init error " .. message.err)
        else
            remote_init(self)
        end
    elseif message_id == hash("forwarded_input") then
        remote_input(self, message.action_id, message.action)
    end
end

function on_input(self, action_id, action)
end
